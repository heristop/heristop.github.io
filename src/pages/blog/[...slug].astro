---
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import Layout from "../../layouts/Layout.astro";
import SocialShare from "../../components/SocialShare.astro";
import RecommendedPosts from "../../components/RecommendedPosts.astro";
import FormattedDate from "../../components/FormattedDate.astro";
import Icon from "../../components/Icon.astro";

const currentPostSlug = Astro.props.slug;

export async function getStaticPaths() {
  const posts = await getCollection("blog");
  return posts.map((post) => ({
    params: { slug: post.slug },
    props: post,
  }));
}
type Props = CollectionEntry<"blog">;

const post = Astro.props;
const { Content } = await post.render();
const conclusion = post.data.conclusion;

const plainText = post.body;
const words = plainText.split(/\s+/).length;
const readingTime = Math.ceil(words / 200);

// Get all posts for navigation
const allPosts = (await getCollection("blog")).toSorted(
  (a, b) => (b.data.pubDate?.valueOf() ?? 0) - (a.data.pubDate?.valueOf() ?? 0)
);

// Find current post index and adjacent posts
const currentIndex = allPosts.findIndex(p => p.slug === currentPostSlug);
const previousPost = currentIndex < allPosts.length - 1 ? allPosts[currentIndex + 1] : undefined;
const nextPost = currentIndex > 0 ? allPosts[currentIndex - 1] : undefined;

const postData = {
  ...post.data,
  readingTime,
};
---

<Layout {...postData}>
  <div class="post-page">
    <div class="post-page__meta">
      <div class="post-page__meta-info">
        <div class="post-page__date">
          <Icon name="calendar" size={16} class="post-page__date-icon" aria-hidden={true} />
          {post.data.pubDate && <FormattedDate date={post.data.pubDate} showYear />}
        </div>
        <div class="post-page__reading-time">
          <Icon name="book" size={16} class="post-page__reading-icon" aria-hidden={true} />
          <span>{readingTime} min read</span>
        </div>
      </div>
      <div class="post-page__share">
        <SocialShare
          class="post-page__share-links"
          title={post.data.title}
          slug={currentPostSlug}
          minimal
        />
      </div>
    </div>

    <Content />

    <blockquote class="post-page__endquote">
      <RecommendedPosts {currentPostSlug} {conclusion} />
    </blockquote>
  </div>

  <script type="module" is:inline define:vars={{ previousPost, nextPost }}>
    // Device detection (global scope)
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const isMobile = () => window.innerWidth <= 768;
    const isTablet = () => window.innerWidth > 768 && window.innerWidth <= 1024;
    const shouldUseTouchNavigation = () => isTouchDevice && (isMobile() || isTablet());

    function initKeyboardNavigation() {
      // Clean up any existing global navigation indicators
      const existingGlobalNav = document.querySelector('.global-navigation-indicators');
      if (existingGlobalNav) {
        existingGlobalNav.remove();
      }

      // Only enable if we have navigation options
      if (!previousPost && !nextPost) {return;}

      let isInputFocused = false;

      function updateInputFocus() {
        const activeElement = document.activeElement;
        isInputFocused = activeElement && (
          activeElement.tagName === 'INPUT' ||
          activeElement.tagName === 'TEXTAREA' ||
          activeElement.tagName === 'SELECT' ||
          activeElement.contentEditable === 'true'
        );
      }

      // Listen for focus/blur on input elements
      document.addEventListener('focusin', updateInputFocus);
      document.addEventListener('focusout', updateInputFocus);

      // Unified navigation function
      function navigateToPost(direction) {
        const targetPost = direction === 'previous' ? previousPost : nextPost;
        if (targetPost) {
          showNavigationHint(direction);
          setTimeout(() => {
            window.location.href = `/blog/${targetPost.slug}/`;
          }, 150);
        }
      }

      // Handle keyboard navigation (desktop only)
      if (!shouldUseTouchNavigation()) {
        document.addEventListener('keydown', (event) => {
          // Skip if input is focused or modifier keys are pressed
          if (isInputFocused || event.ctrlKey || event.metaKey || event.altKey || event.shiftKey) {
            return;
          }

          switch (event.key) {
            case 'ArrowLeft': {
              if (previousPost) {
                event.preventDefault();
                navigateToPost('previous');
              }
              break;
            }

            case 'ArrowRight': {
              if (nextPost) {
                event.preventDefault();
                navigateToPost('next');
              }
              break;
            }
          }
        });
      }

      // Handle touch navigation (mobile/tablet only)
      if (shouldUseTouchNavigation()) {
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        const swipeThreshold = 100; // Minimum distance for swipe
        const swipeTimeout = 500; // Maximum time for swipe
        const verticalThreshold = 50; // Maximum vertical movement

        document.addEventListener('touchstart', (event) => {
          if (isInputFocused) {return;}

          const touch = event.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          touchStartTime = Date.now();
        }, { passive: true });

        document.addEventListener('touchend', (event) => {
          if (isInputFocused || !touchStartX) {return;}

          const touch = event.changedTouches[0];
          const touchEndX = touch.clientX;
          const touchEndY = touch.clientY;
          const touchEndTime = Date.now();

          const deltaX = touchEndX - touchStartX;
          const deltaY = Math.abs(touchEndY - touchStartY);
          const timeDelta = touchEndTime - touchStartTime;

          // Reset touch tracking
          touchStartX = 0;

          // Check if this qualifies as a horizontal swipe
          if (Math.abs(deltaX) > swipeThreshold &&
              deltaY < verticalThreshold &&
              timeDelta < swipeTimeout) {

            if (deltaX > 0 && previousPost) {
              // Swipe right = go to previous post
              event.preventDefault();
              navigateToPost('previous');
            } else if (deltaX < 0 && nextPost) {
              // Swipe left = go to next post
              event.preventDefault();
              navigateToPost('next');
            }
          }
        }, { passive: false });
      }

      // Show brief visual feedback for navigation
      function showNavigationHint(direction) {
        const hint = document.createElement('div');
        hint.className = `navigation-hint navigation-hint--${direction}`;
        hint.textContent = direction === 'previous' ? '← Previous' : 'Next →';
        hint.setAttribute('aria-live', 'polite');

        document.body.append(hint);

        requestAnimationFrame(() => {
          hint.style.opacity = '1';
          hint.style.transform = 'translateY(0)';
        });

        setTimeout(() => {
          hint.style.opacity = '0';
          hint.style.transform = 'translateY(-10px)';
          setTimeout(() => {
            if (hint.parentNode) {
              hint.parentNode.removeChild(hint);
            }
          }, 300);
        }, 1000);
      }

      // Add navigation hints to page
      createNavigationIndicators();
    }

    function createNavigationIndicators() {
      const indicators = document.createElement('div');
      indicators.className = 'post-navigation-indicators';
      indicators.setAttribute('role', 'region');
      indicators.setAttribute('aria-label', 'Blog post navigation');

      const indicatorHTML = [];

      if (previousPost) {
        indicatorHTML.push(`
          <button
            class="post-nav-indicator post-nav-indicator--left"
            title="Previous: ${previousPost.data.title.replaceAll(/"/g, '&quot;')}"
            aria-label="Previous post: ${previousPost.data.title.replaceAll(/"/g, '&quot;')}"
            onclick="window.location.href = '/blog/${previousPost.slug}/'"
          >←</button>
        `);
      }

      if (nextPost) {
        indicatorHTML.push(`
          <button
            class="post-nav-indicator post-nav-indicator--right"
            title="Next: ${nextPost.data.title.replaceAll(/"/g, '&quot;')}"
            aria-label="Next post: ${nextPost.data.title.replaceAll(/"/g, '&quot;')}"
            onclick="window.location.href = '/blog/${nextPost.slug}/'"
          >→</button>
        `);
      }

      if (previousPost || nextPost) {
        const hintText = shouldUseTouchNavigation()
          ? 'Swipe left/right to navigate reflections'
          : 'Use ← → keys to navigate reflections';

        indicatorHTML.push(`
          <span
            class="post-nav-hint"
            role="status"
            aria-live="polite"
          >${hintText}</span>
        `);
      }

      indicators.innerHTML = indicatorHTML.join('');
      document.body.append(indicators);
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initKeyboardNavigation);
    } else {
      initKeyboardNavigation();
    }

    // Reinitialize on page navigation (for SPA-like behavior)
    document.addEventListener('astro:page-load', initKeyboardNavigation);
  </script>
</Layout>
